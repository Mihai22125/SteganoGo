package png

import (
	. "gopkg.in/check.v1"
)

// Hook up gocheck into the "go test" runner.
//func Test(t *testing.T) { TestingT(t) }

type MySuiteEncode struct {
}

var _ = Suite(&MySuite{})

func (m *MySuite) TestEncode(c *C) {

	tt := []struct {
		name           string
		png            StructPNG
		expectedResult []byte
		expectedErr    error
	}{
		{
			name: "ShouldPass",
			png: StructPNG{header: Header{signature: []uint8{0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa}}, chunks: []Chunk{Chunk{size: 0xd,
				chunkType: "IHDR", data: []uint8{0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x20, 0x1, 0x0, 0x0, 0x0, 0x0}, crc: 0x5b014759}, Chunk{size: 0x4, chunkType: "gAMA", data: []uint8{0x0, 0x1, 0x86, 0xa0}, crc: 0x31e8965f}, Chunk{size: 0x5b, chunkType: "IDAT", data: []uint8{0x78, 0x9c, 0x2d, 0xcc, 0xb1, 0x9, 0x3, 0x30, 0xc, 0x5, 0xd1, 0xeb, 0xd2, 0x4, 0xb2, 0x4a, 0x20, 0xb, 0x7a, 0x34, 0x6f, 0x90, 0x15, 0x3c, 0x82, 0xc1, 0x8d, 0xa, 0x61, 0x45, 0x7, 0x51, 0xf1, 0xe0, 0x8a, 0x2f, 0xaa, 0xea, 0xd2, 0xa4, 0x84, 0x6c, 0xce, 0xa9, 0x25, 0x53, 0x6, 0xe7, 0x53, 0x34, 0x57, 0x12, 0xe2, 0x11, 0xb2, 0x21, 0xbf, 0x4b, 0x26, 0x3d, 0x1b, 0x42, 0x73, 0x25, 0x25, 0x5e, 0x8b, 0xda, 0xb2, 0x9e, 0x6f, 0x6a, 0xca, 0x30, 0x69, 0x2e, 0x9d, 0x29, 0x61, 0x6e, 0xe9, 0x6f, 0x30, 0x65, 0xf0, 0xbf, 0x1f, 0x10, 0x87, 0x49, 0x2f}, crc: 0xd02f14c9}, Chunk{size: 0x0, chunkType: "IEND", data: []uint8{}, crc: 0xae426082}}},
			expectedResult: []byte{0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49, 0x48, 0x44, 0x52, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x20, 0x1, 0x0, 0x0, 0x0, 0x0, 0x5b, 0x1, 0x47, 0x59, 0x0, 0x0, 0x0, 0x4, 0x67, 0x41, 0x4d, 0x41, 0x0, 0x1, 0x86, 0xa0, 0x31, 0xe8, 0x96, 0x5f, 0x0, 0x0, 0x0, 0x5b, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x2d, 0xcc, 0xb1, 0x9, 0x3, 0x30, 0xc, 0x5, 0xd1, 0xeb, 0xd2, 0x4, 0xb2, 0x4a, 0x20, 0xb, 0x7a, 0x34, 0x6f, 0x90, 0x15, 0x3c, 0x82, 0xc1, 0x8d, 0xa, 0x61, 0x45, 0x7, 0x51, 0xf1, 0xe0, 0x8a, 0x2f, 0xaa, 0xea, 0xd2, 0xa4, 0x84, 0x6c, 0xce, 0xa9, 0x25, 0x53, 0x6, 0xe7, 0x53, 0x34, 0x57, 0x12, 0xe2, 0x11, 0xb2, 0x21, 0xbf, 0x4b, 0x26, 0x3d, 0x1b, 0x42, 0x73, 0x25, 0x25, 0x5e, 0x8b, 0xda, 0xb2, 0x9e, 0x6f, 0x6a, 0xca, 0x30, 0x69, 0x2e, 0x9d, 0x29, 0x61, 0x6e, 0xe9, 0x6f, 0x30, 0x65, 0xf0, 0xbf, 0x1f, 0x10, 0x87, 0x49, 0x2f, 0xd0, 0x2f, 0x14, 0xc9, 0x0, 0x0, 0x0, 0x0, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82},
		},
	}

	for _, tc := range tt {
		encodedBuf, err := tc.png.Encode()
		c.Assert(err, IsNil)
		encoded := encodedBuf.Bytes()
		c.Assert(encoded, DeepEquals, tc.expectedResult)
	}

	/*
		testPath := "../../../test_files/png_test_files/test_files/01.basic_formats"

		testFile, err := os.Open(testPath + "/basn0g01.png")
		c.Assert(err, IsNil)

		defer testFile.Close()

		original, err := ParsePNG(testFile)
		c.Assert(err, IsNil)

		buf, err := original.Encode()
		c.Assert(err, IsNil)
		c.Assert(buf.Bytes(), Equals, []byte{})

		err = ioutil.WriteFile("dat1.png", buf.Bytes(), 0644)
		c.Assert(err, IsNil)
	*/
}
