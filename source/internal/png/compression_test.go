package pngint

import (
	"io"
	"testing"

	. "gopkg.in/check.v1"
)

// Hook up gocheck into the "go test" runner.
func Test(t *testing.T) { TestingT(t) }

type MySuite struct {
	compressor *Compressor
}

var _ = Suite(&MySuite{})

func (s *MySuite) SetUpSuite(c *C) {
	s.compressor = NewCompressor()
}

func (s *MySuite) TestDecompressPNGData(c *C) {

	tt := []struct {
		name           string
		input          []byte
		method         CompressionMethod
		expectedResult []byte
		expectedError  error
	}{
		{
			name:           "ShouldPass1 - hello world",
			method:         ComprDeflate,
			input:          []byte{120, 156, 202, 72, 205, 201, 201, 215, 81, 40, 207, 47, 202, 73, 225, 2, 4, 0, 0, 255, 255, 33, 231, 4, 147},
			expectedResult: []byte("hello, world\n"),
			expectedError:  nil,
		},
		{
			name:   "ShouldPass2 - png data sample",
			method: ComprDeflate,
			input:  []byte{0x78, 0x9c, 0x2d, 0xcc, 0xb1, 0x9, 0x3, 0x30, 0xc, 0x5, 0xd1, 0xeb, 0xd2, 0x4, 0xb2, 0x4a, 0x20, 0xb, 0x7a, 0x34, 0x6f, 0x90, 0x15, 0x3c, 0x82, 0xc1, 0x8d, 0xa, 0x61, 0x45, 0x7, 0x51, 0xf1, 0xe0, 0x8a, 0x2f, 0xaa, 0xea, 0xd2, 0xa4, 0x84, 0x6c, 0xce, 0xa9, 0x25, 0x53, 0x6, 0xe7, 0x53, 0x34, 0x57, 0x12, 0xe2, 0x11, 0xb2, 0x21, 0xbf, 0x4b, 0x26, 0x3d, 0x1b, 0x42, 0x73, 0x25, 0x25, 0x5e, 0x8b, 0xda, 0xb2, 0x9e, 0x6f, 0x6a, 0xca, 0x30, 0x69, 0x2e, 0x9d, 0x29, 0x61, 0x6e, 0xe9, 0x6f, 0x30, 0x65, 0xf0, 0xbf, 0x1f, 0x10, 0x87, 0x49, 0x2f},
			expectedResult: []byte{0x0, 0xff, 0xff, 0xff, 0xfe, 0x0, 0xff, 0xff, 0xff, 0xfc, 0x0, 0xff, 0xff, 0xff, 0xf8, 0x0, 0xff, 0xff, 0xff, 0xf0, 0x0, 0xf3, 0xf3, 0xff, 0xe0, 0x0, 0xf3, 0xf3, 0xff, 0xc0, 0x0, 0xf3, 0xf3, 0xff, 0x80, 0x0, 0xf3, 0x33, 0xff, 0x0, 0x0, 0xf3, 0x33,
				0xfe, 0x0, 0x0, 0xf3, 0x33, 0xfc, 0x0, 0x0, 0xf8, 0x7, 0xf8, 0x0, 0x0, 0xf8, 0x7, 0xf0, 0x0, 0x0, 0xfc, 0xcf, 0xe0, 0x0, 0x0, 0xfc, 0xcf, 0xc0, 0x0, 0x0, 0xff, 0xff, 0x80, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xfe, 0x0, 0x0, 0x0, 0xff, 0xfc, 0x0, 0x0, 0x0, 0xff, 0xf8, 0xf, 0xe0, 0x0, 0xff, 0xf0, 0xf, 0xe0, 0x0, 0xff, 0xe0, 0xc, 0x30, 0x0, 0xff, 0xc0, 0xc, 0x30, 0x0, 0xff, 0x80, 0xf, 0xe0, 0x0, 0xff, 0x0, 0xf, 0xe0, 0x0, 0xfe, 0x0, 0xc, 0x30, 0x0, 0xfc, 0x0, 0xc, 0x30, 0x0, 0xf8, 0x0, 0xf, 0xe0, 0x0, 0xf0, 0x0, 0xf, 0xe0, 0x0, 0xe0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
			expectedError: nil,
		},
		{
			name:           "ShouldFail1 - invalid compression method",
			method:         CompressionMethod(1),
			input:          []byte{120, 156, 202, 72, 205, 201, 201, 215, 81, 40, 207, 47, 202, 73, 225, 2, 4, 0, 0, 255, 255, 33, 231, 4, 147},
			expectedResult: nil,
			expectedError:  ErrNotSupportedPNG,
		},
		{
			name:           "ShouldFail1 - invalid compressed data input",
			method:         ComprDeflate,
			input:          []byte{0x78, 0x9c, 0x2d, 0xcc},
			expectedResult: nil,
			expectedError:  io.ErrUnexpectedEOF,
		},
	}

	for _, tc := range tt {
		decompressedData, err := s.compressor.DecompressPNGData(tc.input, tc.method)
		c.Assert(err, Equals, tc.expectedError)
		c.Assert(decompressedData, DeepEquals, tc.expectedResult)
	}
}

func (s *MySuite) TestCompressPNGData(c *C) {

	tt := []struct {
		name           string
		input          []byte
		method         CompressionMethod
		expectedResult []byte
		expectedError  error
	}{
		{
			name:           "ShouldPass1 - hello world",
			method:         ComprDeflate,
			input:          []byte("hello, world\n"),
			expectedResult: []byte{120, 156, 202, 72, 205, 201, 201, 215, 81, 40, 207, 47, 202, 73, 225, 2, 4, 0, 0, 255, 255, 33, 231, 4, 147},
			expectedError:  nil,
		},

		{
			name:   "ShouldPass2 - png data sample",
			method: ComprDeflate,
			input: []byte{0x0, 0xff, 0xff, 0xff, 0xfe, 0x0, 0xff, 0xff, 0xff, 0xfc, 0x0, 0xff, 0xff, 0xff, 0xf8, 0x0, 0xff, 0xff, 0xff, 0xf0, 0x0, 0xf3, 0xf3, 0xff, 0xe0, 0x0, 0xf3, 0xf3, 0xff, 0xc0, 0x0, 0xf3, 0xf3, 0xff, 0x80, 0x0, 0xf3, 0x33, 0xff, 0x0, 0x0, 0xf3, 0x33,
				0xfe, 0x0, 0x0, 0xf3, 0x33, 0xfc, 0x0, 0x0, 0xf8, 0x7, 0xf8, 0x0, 0x0, 0xf8, 0x7, 0xf0, 0x0, 0x0, 0xfc, 0xcf, 0xe0, 0x0, 0x0, 0xfc, 0xcf, 0xc0, 0x0, 0x0, 0xff, 0xff, 0x80, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xfe, 0x0, 0x0, 0x0, 0xff, 0xfc, 0x0, 0x0, 0x0, 0xff, 0xf8, 0xf, 0xe0, 0x0, 0xff, 0xf0, 0xf, 0xe0, 0x0, 0xff, 0xe0, 0xc, 0x30, 0x0, 0xff, 0xc0, 0xc, 0x30, 0x0, 0xff, 0x80, 0xf, 0xe0, 0x0, 0xff, 0x0, 0xf, 0xe0, 0x0, 0xfe, 0x0, 0xc, 0x30, 0x0, 0xfc, 0x0, 0xc, 0x30, 0x0, 0xf8, 0x0, 0xf, 0xe0, 0x0, 0xf0, 0x0, 0xf, 0xe0, 0x0, 0xe0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
			expectedResult: []byte{0x78, 0x9c, 0x2c, 0xc7, 0xb1, 0x9, 0xc3, 0x30, 0x14, 0x6, 0xe1, 0xeb, 0xd2, 0x18, 0xbc, 0x8a, 0xc1, 0xb, 0x6a, 0x34, 0x6d, 0x90, 0x15, 0xde, 0x8, 0x2, 0x35, 0x2a, 0x84, 0xfe, 0x70, 0x90, 0x2b, 0x3e, 0x38, 0x92, 0x1c, 0xd9, 0xb2, 0x64, 0x30, 0x67, 0x4a, 0xba, 0x34, 0xe6, 0x1b, 0x98, 0xef, 0x91, 0xd, 0xeb, 0xb3, 0x64, 0xc0, 0xfe, 0x96, 0x74, 0x48, 0x9a, 0x0, 0x39, 0xb2, 0x65, 0xdd, 0x45, 0x86, 0xd4, 0xf5, 0x90, 0x2e, 0xcd, 0xe5, 0x2e, 0xe, 0xd7, 0xc3, 0x96, 0xe5, 0xe, 0x29, 0x80, 0x2e, 0x8d, 0x7f, 0xbf, 0x0, 0x0, 0x0, 0xff, 0xff, 0x10, 0x87, 0x49, 0x2f},
			expectedError:  nil,
		},

		{
			name:           "ShouldFail1 - invalid decompression method",
			method:         CompressionMethod(1),
			input:          []byte{120, 156, 202, 72, 205, 201, 201, 215, 81, 40, 207, 47, 202, 73, 225, 2, 4, 0, 0, 255, 255, 33, 231, 4, 147},
			expectedResult: nil,
			expectedError:  ErrNotSupportedPNG,
		},
	}

	for _, tc := range tt {
		compressedData, err := s.compressor.CompressPNGData(tc.input, tc.method)
		c.Assert(err, Equals, tc.expectedError)
		c.Assert(compressedData, DeepEquals, tc.expectedResult)
	}

}
